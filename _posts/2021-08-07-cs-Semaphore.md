---
title: cs-Semaphore
author: YHole
date: 2021-08-07 +0900
categories: [CS, Operating System]
tags: [cs, Operating System]
---

## Thread (스레드)

- Light Weight Process라고도 한다
- 하나의 프로세스에 여러개의 스레드 생성 가능(서브 셋)
- 스레드들은 동시에 실행 가능
- 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능

- 장점
  - 사용자에 대한 응답성 향상
  - 자원 공유 효율

- 단점
  - 스레드 중 하나만 문제가 생겨도 전체 영향
  - 스레드를 많이 생성하게 되면  
Context Switching이 많이 일어나 성능 저하

### 프로세스 내부

- 공통 부분
  - data
  - files
  - code

- 개별 부분
  - registers
  - stack

하나의 프로세스에서 병행 작업 처리를 위해 Multi Thread 사용

### 동기화(Synchronization) 이슈

- 여러 스레드가 동일한 자원(데이터)에 접근시 동기화 이슈 발생
- 작업들 사이에 실행 시기를 맞추는 것

#### 해결 방안

- Mutual exclusion (상호 배제)
```c
// 임계 자원(critical resource)
// 임계 영역(critical section)
lock.acquire()
for i in range(100000):
g_count += 1
lock.release()
```
- 쓰레드는 프로세스 모든 데이터를 접근할 수 있으므로,  
여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요  
어느 한 스레드가 공유 변수를 갱신하는 동안  
다른 스레그가 동시 접근하지 못하도록 막아야 한다

- Mutex와 Semaphore(세마포어)
  - Critical Section에 대한 접근을 막기 위해 LOCKING메커니즘이 필요

  - Mutex(binary semaphore)  
  임계구역에 하나의 스레드만 들어갈 수 있음

  - Semaphore  
  임계구역에 여러 스레드가 들어갈 수 있음  
  counter를 두어 동시에 리소스에 접근 할 수 있는 스레드 수를 제어

#### Semaphore

P: 검사 (임계영역에 들어갈 때)  
S값이 1 이상이면, 임계 영역 진입 후, S값 1 차감 (S값이 0이면 대기)
V: 증가 (임계영역에서 나올 때)  
S값을 1 더하고, 임계 영역을 나옴  
S: 세마포어 값 (초기 값만큼 여러 프로세스가 동시 임계 영역 접근 가능)

```c
P(S): wait(S) {
  while S <= 0 // 대기
  ;
  S--; // 다른 프로세스 접근 제한
}
// 바쁜 대기
// 임계 영역에 들어가기 위해 반복문 계속 수행

V(S): signal(S) {
S++; // 다른 프로세스 접근 허용
}
```
- 대기큐
  - loop는 CPU에게 부하를 줌

```c
// 대기큐로 보내기
wait(S) {
  S->count--;
  if (S->count <= 0) {
    add this process to S->queue;
    block()
  }
}

signal(S) {
  S->count++;
  if (S->count > 0) {
    remove a process P from S->queue;
    // 대기큐의 프로세스 재 실행
    wakeup(P)
  }
}
```
- POSIX Threads(PThread)  
병렬적으로 작동하는 소프트웨어의 작성을 위해서 제공되는 표준 API

  - sem_open() : 세마포어를 생성
  - sem_wait() : 임계영역 접근 전, 세마포어를 잠그고,  
  세마포어가 잠겨있다면, 풀릴 때까지 대기
  - sem_post() : 공유자원에 대한 접근이 끝났을 때  
  세마포어 잠금을 해제한다.


#### 교착상태(deadlock)

- 무한 대기 상태  
둘 이상의 작업이 서로 상대방의 종료를 기다리고 있는 상태

> 프로세스, 스레드 둘다 이와 같은 상태가 일어날 수 있다

- 다음 네 가지 조건이 모두 성립될 때, 교착상태 발생 가능성이 있음
1. 상호배제(Mutual exclusion): 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
2. 점유대기(Hold and wait): 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
3. 비선점(No preemption): 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
4. 순환대기(Circular wait): 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.


#### 교착상태 해결법

1. 예방(deadlock prevention)
  - 4가지 조건 중 하나를 제거하는 방법
    1. 상호배제 조건의 제거: 임계 영역 제거
    2. 점유와 대기 조건의 제거: 한번에 모든 필요 자원 점유 및 해제
    3. 비선점 조건 제거: 선점 가능 기법을 만들어줌
    4. 순환 대기 조건 제거: 자원 유형에 따라 순서를 매김
2. 회피(deadlock avoidance)
  - 4번만 제거
  - 순환 대기 조건 제거: 자원 유형에 따라 순서를 매김
3. 발견(deadlock detection)
  - 교착상태가 발생했는지 점검하여  
  교착 상태에 있는 프로세스와 자원을 발견하는 것
4. 회복(deadlock recovery)
  - 교착 상태를 일으킨 프로세스를 종료하거나  
  교착상태의 프로세스에 할당된 자원을 선점하여 프로세
스나 자원을 회복하는 것

#### 기아상태(starvation)

- 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
- 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때,  
특정 프로세스는 영원히 자원 할당이 안되는 경우를 주로 의미함

#### 기아상태 해결법

- 우선순위 변경
  - 프로세스 우선순위를 수시로 변경해서,  
  각 프로세스가 높은 우선순위를 가질 기회주기
  - 오래 기다린 프로세스의 우선순위를 높여주기
  - 우선순위가 아닌, 요청 순서대로 처리하는 FIFO 기반 요청큐 사용


### 헷갈림 포인트

- 멀티 태스킹  
단일 CPU에서 여러가지 작업이 이루어지게 보이는 방식

- 멀티 프로세싱  
하나의 프로세스를 여러 CPU에서 나누어 작업(프로세스 수 ↑)

- 멀티 스레드  
하나의 프로세스 내부에 스레드가 생김(프로세스 수 변화 X)
