---
title: cs-Virtual Memory System
author: YHole
date: 2021-08-07 +0900
categories: [CS, Operating System]
tags: [cs, Operating System]
---

## Virtual Memory System (가상 메모리)

> 폰노이만 구조 기반이므로, 코드는 메모리에 반드시 있어야 함

> 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음

- 메모리가 실제 메모리보다 많아 보이게 하는 기술
- 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
- 프로세스간 공간 분리로, 프로세스 이슈가  
전체 시스템에 영향을 주지 않을 수 있음

- 가상 메모리 기본 아이디어
  - 프로세스는 가상 주소를 사용,  
  실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔주면 된다.
  - virtual address (가상 주소): 프로세스가 참조하는 주소
  - physical address (물리 주소): 실제 메모리 주소
- MMU(Memory Management Unit)
  - CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할 때,  
  해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

> CPU =>(가상) MMU =>(물리) Memory

## paging system

### 기본 개념

- 프로세스(4GB)의 PCB에 Page Table 구조체를 가리키는 주소가 들어있음
  - 32bit 시스템에서 2의 32승은 4GB(커널 1GB, 사용자 영역 3GB)
- 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭되는  
물리주소 공간을 관리
- 하드웨어 지원이 필요  
  - intelx86 32bit 에서는 4KB, 2MB, 1GB 지원
  - 리눅스에서는 4KB
- 페이지 번호를 기반으로 가상주소/물리조소 매핑 정보를 기록/사용

### Page Table 구조

- page(page frame): 고정된 크기의 block (4kb)
- 가상 주소 v = (p,d)
  - 페이지 번호 + 변위(오프셋)
  - p : 가상 메모리 페이지 정보 12 비트 이상
  - d : p안에서 참조하는 위치 0~11비트

### Page Table 동작

- 프로세스 생성시, 페이지 테이블 정보 생성
  - PCB등에서 해당 page table에 접근, 관련 정보는 물리 메모리에 적재
  - 프로세스 구동시, 해당 page table base 주소가  
  별도 레지스터에 저장(CR3)
  - MMU가 page table base에 접근하여, 물리주소 가져옴

1. PCB에서 요청 => 가상 주소 엑세스 p + d
2. 해당 프로세스의 page table에 page번호가 있는지 확인
3. 페이지 번호가 있다면 page가 매핑된 첫 물리주소 p'를 확인
4. p' + d 가 실제 물리 주소로 사용됨

### 공유 메모리

- 프로세스간 동일한 물리 주소를 가리킬 수 있다
  - 공간 절약, 메모리 할당 시간 절약
- 공유하던 물리 주소에서 데이터 변경이 일어날 경우
  - 물리 주소를 복사하여 물리 메모리 내의 주소 변경
  - 즉 테이블이 page pointer를 변경

### 요구 페이징 (Demand paging)

- 프로세스 모든 데이터를 메모리로 적재하지 않고  
실행 중 필요한 시점에서만 메모리로 적재
  - 선행 페이징의 반대 개념이 된다
  - 필요하지 않은 페이지 프레임은 다시 저장매체로
    - 페이지 교체 알고리즘이 필요하다

### 페이지 교체 정책 (page replacement policy)

- 물리 메모리가 다 차있을 경우
  - 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내림
  - 새로운 페이지를 해당 공간에 올림

#### 교체 알고리즘 (page replacement algorithm)

- FIFO
  - 가장 먼저 들어온 페이지를 내림

- OPT
  - optimal(최적의)페이지를 내림
  - 최적? => 가장 오랫동안 사용하지 않을 페이지 내림
  - 일반 OS에서는 구현 불가

- LRU
  - Least Recently Used
  - 가장 오래 전에 사용된 페이지를 내림
  - OTP 구현이 안되므로, 과거 기록을 기반으로 시도

- LFU
  - Least Frequently Used
  - 가장 적게 사용된 페이지를 내림

- NUR
  - Not Used Recently
  - 최근에 사용하지 않은 페이지를 내림
  - 각 페이지별 참조(R), 수정(M) 비트를 둔다
  - (0,0), (0,1), (1,0), (1,1) 순으로 교체

### 페이지 폴트 (page fault)

- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제가 해당 페이지를 물리 메모리에 올림
  - 시간이 오래 걸림

## 다중 단계 페이징 시스템

- 32bit 시스템에서 4kb 페이지를 위한 페이징 시스템은
  - 하위 12bit는 오프셋
  - 상위 20bit가 페이징 번호, 2의 20승(1048576)개의 페이지 정보 필요

- 페이징 정보를 단계를 나누어 생성
  - 필요없는 페이지는 생성안함, 공간 절약 가능
  - page directory : 실제 데이터를 담고 있는 페이지를 등록하여 구분함

- 페이지 번호를 나타내는 bit를 구분하여 단계를 나눔
![page](/assets/img/docsitem/pagetable.jpg)


- CR3 레지스터가 page directory baseAddress로 접근
- page directory 정보를 찾아내서 page table로 접근
- 오프셋으로 접근하여 물리주소 확인

![tlb](/assets/img/docsitem/tlb.jpg)


## Segmentation 기법

- 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트로 분할
  - x86 리얼모드는 이하로 세그먼트를 나누어 메모리 접근
    - CS Code Segment
    - DS Data Segment
    - SS Stack Segment
    - ES Extra Segment
- 가상 주소 v = (s,d)
  - s: 세그먼트
  - d: 변위

- paging과 비교하면 물리 메모리의 차지하는 크기가 세그먼트 별로 다르다



- 내부 단편화(paging)
  - 페이지 블록만큼 데이터가 딱 맞게 채워져 있지 않을 때 공간 낭비
- 외부 단편화(segmentation)
  - 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우
- 하드웨어 지원 필요
  - 두 방법다 필요
  - 다양한 컴퓨터 시스템에 이식성을 중시하는  
  리눅스는 페이징 기법을 기반으로 구현

- Thrashing (스레싱)  
> 반복적으로 페이지 폴트가 발생하여, 실제적으로 아무일도 하지 못하는 상황
